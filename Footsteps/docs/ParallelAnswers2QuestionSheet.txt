Solutions for Parallel Programming: 
18. Embarrasingly Parallel - The algorithm requires lttle to no overhead 
to get the work done soeed out over multiple processors.

-  If there were no overhead at all, they would solve the problem at the 
same time. 
    If there were any overhead, then the single processor will solve the
problem much faster. 
    However, if you run the same program on 8 different processors it 
will use 64 times less power, because of 8 squared. 


19. Odd Even Transopition runs at O(n), and it works:


20. They can swap values with their neighbors based on whether its
greater or less than by comparison. 
    It has the hardware that it absolutely needs, and nothing else. 
a Corei7 is built for general purpose, and has everything under the sun to solve your problems, but it's 
more than you'll need. 
    One trafde off is the corei7 is general purpose and the other 
processor has limited uses. The grid processor is more efficient for 
sorting because of its specific use, as opposed t the corei7 which 
is more general. One is nlogn, and the other is swaureroot of n times n
because of parallelism. 

21. ANy algorithm that is based on the oblivious comparison exchange
that can sort 0s and 1s can sort any piece of data. 

22. Does an Odd Even Transposition sort on every row and column 
log of sqaure root of n + 1, and then the columns log of sqaure root 
of n. 

23. Every time you do a row followed by a column sort, at least half
the rows are sorted, and that can't take more than log n, because base
2 that's the number of times something that can be broken in half. 

24. 

25. We got the CPU with the registers, then we have the L1 Cache, and
the L2 Cache, which is shared with another CPU. There's even an L3 
cache which is shared with more CPU's. The L3 goes to the main memory.
The main memory is ofcourse the biggest memory. 

Soln: THe main memory is a large memory, but much slower then the CPU.
the l3 cache used to be a sepreate cache, and is rather large and its
not as fast as the other caches because it's a bigger cache, and it 
serves all n cores depending on n. Then there is another level L2, and 
is smaller than the L3 and main memory, and there fore faster, and then 
there is the L1 cache which links to just 1 CPU as opposed to 2 like the 
L2, and is ofcourse logically faster. If you have two processor using a 
shared variable then the seperate L1's are invalidated and the L2's are 
invalidated, and they have to go to the L3 to get the value. This 
memory hieracrchy affects the ... because it 

If you make a change to the variable that is shared between a processor. 
Even though some processors can recognize, it'll be an enormous slowdown. 

27. Everytime the clock ticks a new answer comes out. 

28. Evaluating that polynomial at roots of unity.
-Applying an FFT of order n to a polynomial of degree n-1 is equivalent 
to evaluating that polynomial at the nth roots of unity (In general the 
"nth" roots of unity have "n" terms)

29. They cancel out and give back the original value, because you're 
calling an inverse FFT to the original solution (That an FFT would 
solve) essentially canceling out and giving back the original value.

30. 

31. Image Compression, Doing polynomial multiplication, Analyze sound
and find out what frequency a certain sound is in, 

32. 

35. They aren't different